"""
股票池生成器
用于生成每日涨停股票池，避免在选股时实时获取
"""

import akshare as ak
import pandas as pd
import numpy as np
import os
import sqlite3
from datetime import datetime, timedelta
import time
import warnings
import glob
from typing import List, Dict
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor
warnings.filterwarnings('ignore')

class StockPoolGenerator:
    def __init__(self, data_dir="full_stock_data"):
        self.data_dir = data_dir
        self.daily_data_dir = os.path.join(data_dir, "daily_data")
        self.db_path = os.path.join(data_dir, "stock_data.db")
        self.pool_data_dir = os.path.join(data_dir, "pool_data")  # 新增：股票池数据目录
        
        # 确保目录存在
        if not os.path.exists(self.daily_data_dir):
            os.makedirs(self.daily_data_dir)
        if not os.path.exists(self.pool_data_dir):
            os.makedirs(self.pool_data_dir)
    
    def get_last_trading_date(self, target_date: str) -> str:
        """获取指定日期的前一个交易日"""
        target_dt = datetime.strptime(target_date, '%Y-%m-%d')
        current_dt = target_dt - timedelta(days=1)
        
        # 循环查找前一个交易日
        while True:
            # 检查是否为周末
            if current_dt.weekday() < 5:  # 0-4 是工作日
                # 检查是否为节假日（这里简化处理，只检查周末）
                date_str = current_dt.strftime('%Y-%m-%d')
                
                # 检查该日期是否有数据
                has_data = False
                for file in os.listdir(self.daily_data_dir)[:100]:  # 只检查前100个文件
                    if file.endswith('.csv'):
                        csv_path = os.path.join(self.daily_data_dir, file)
                        try:
                            df = pd.read_csv(csv_path)
                            if 'date' in df.columns:
                                df['date'] = pd.to_datetime(df['date'])
                                if pd.to_datetime(date_str) in df['date'].values:
                                    has_data = True
                                    break
                        except:
                            continue
                
                if has_data:
                    return date_str
            
            current_dt -= timedelta(days=1)
    
    def get_limit_up_stocks_from_daily_data(self, date_str: str) -> List[str]:
        """从本地日线数据中获取涨停股票（通过价格计算）"""
        limit_up_stocks = []
        
        # 遍历所有日线数据文件
        csv_files = glob.glob(os.path.join(self.daily_data_dir, "*.csv"))
        
        for i, file_path in enumerate(csv_files):
            if i % 500 == 0:
                print(f"检查进度: {i}/{len(csv_files)}")
            
            try:
                df = pd.read_csv(file_path)
                
                # 先检查原始列名，决定如何处理
                original_columns = df.columns.tolist()
                
                # 检查是否存在中文列名，如果存在则进行重命名
                column_mapping = {}
                for orig_col in original_columns:
                    if '涨\u3000跌\u3000幅' in orig_col or orig_col == '涨\u3000跌\u3000幅':
                        column_mapping[orig_col] = 'pct_change'
                    elif '涨\u3000跌\u3000额' in orig_col or orig_col == '涨\u3000跌\u3000额':
                        column_mapping[orig_col] = 'change'
                    elif '股\u3000票\u3000代\u3000码' in orig_col or orig_col == '股\u3000票\u3000代\u3000码':
                        column_mapping[orig_col] = 'code'
                    elif '开\u3000盘' in orig_col or orig_col == '开\u3000盘':
                        column_mapping[orig_col] = 'open'
                    elif '收\u3000盘' in orig_col or orig_col == '收\u3000盘':
                        column_mapping[orig_col] = 'close'
                    elif '最\u3000高' in orig_col or orig_col == '最\u3000高':
                        column_mapping[orig_col] = 'high'
                    elif '最\u3000低' in orig_col or orig_col == '最\u3000低':
                        column_mapping[orig_col] = 'low'
                    elif '成\u3000交\u3000量' in orig_col or orig_col == '成\u3000交\u3000量':
                        column_mapping[orig_col] = 'volume'
                    elif '成\u3000交\u3000额' in orig_col or orig_col == '成\u3000交\u3000额':
                        column_mapping[orig_col] = 'amount'
                    elif '振\u3000幅' in orig_col or orig_col == '振\u3000幅':
                        column_mapping[orig_col] = 'amplitude'
                    elif '换\u3000手\u3000率' in orig_col or orig_col == '换\u3000手\u3000率':
                        column_mapping[orig_col] = 'turnover'
                
                df.rename(columns=column_mapping, inplace=True)
                
                df['date'] = pd.to_datetime(df['date'])
                
                # 查找指定日期的数据
                day_data = df[df['date'] == pd.to_datetime(date_str)]
                if day_data.empty:
                    continue
                
                day_data = day_data.iloc[0]
                
                # 获取前一个交易日的数据来计算涨停价
                prev_day_data = df[df['date'] < pd.to_datetime(date_str)]
                if prev_day_data.empty:
                    continue
                
                prev_day_data = prev_day_data.tail(1).iloc[0]
                prev_close = float(prev_day_data['close'])
                
                if prev_close == 0:
                    continue
                
                # 获取股票代码
                stock_code = os.path.basename(file_path).replace('.csv', '')
                
                # 计算涨停价（普通股票10%，ST股票5%）
                is_st = 'ST' in stock_code or 'st' in stock_code
                limit_ratio = 0.05 if is_st else 0.1
                limit_price = round(prev_close * (1 + limit_ratio), 2)
                
                # 判断是否涨停（当日涨幅大于等于9.75%）
                # 优先使用pct_change列，如果没有则尝试其他可能的列名
                current_pct_change = day_data['pct_change'] if 'pct_change' in df.columns else None
                if pd.isna(current_pct_change):
                    # 如果pct_change是NaN，尝试从原始数据中获取
                    # 重新读取该行的原始数据
                    with open(file_path, 'r', encoding='utf-8') as f:
                        lines = f.readlines()
                        for line in lines:
                            if date_str in line and (stock_code in line or stock_code.lstrip('0') in line):  # 匹配原始股票代码或去掉前导零的代码
                                parts = line.strip().split(',')
                                if len(parts) > 9:  # '涨\u3000跌\u3000幅\u3000' 通常在第9列（索引从0开始）
                                    try:
                                        current_pct_change = float(parts[9])
                                        break
                                    except (ValueError, IndexError):
                                        current_pct_change = 0.0
                                else:
                                    current_pct_change = 0.0
                                break
                else:
                    current_pct_change = float(current_pct_change)
                
                if current_pct_change >= 9.75:  # 当日涨幅大于等于9.75%
                    limit_up_stocks.append(stock_code)
                    
            except Exception as e:
                # print(f"处理文件 {file_path} 时出错: {e}")
                continue
        
        return limit_up_stocks
    
    def get_limit_up_stocks_from_api(self, date_str: str) -> List[str]:
        """从API获取涨停股票（备用方法）"""
        try:
            # 将日期格式从 YYYY-MM-DD 转换为 YYYYMMDD
            date_formatted = date_str.replace('-', '')
            
            # 获取涨停股池数据
            df = ak.stock_zt_pool_em(date=date_formatted)
            
            if df.empty:
                return []
            
            # 直接使用列的索引获取股票代码，第1列（索引为1）是股票代码
            limit_up_stocks = df.iloc[:, 1].tolist()  # '代\u3000码\u3000' 列
            return limit_up_stocks
        except Exception as e:
            print(f"从API获取涨停股票数据失败 {date_str}: {e}")
            return []
    
    def generate_stock_pool(self, target_date: str) -> Dict:
        """生成指定日期的股票池"""
        print(f"开始生成 {target_date} 的股票池...")
        
        # 获取前一个交易日
        prev_trading_date = self.get_last_trading_date(target_date)
        print(f"前一个交易日: {prev_trading_date}")
        
        # 从前一个交易日的数据中获取涨停股票
        print("正在从本地数据获取前一日涨停股票...")
        limit_up_stocks = self.get_limit_up_stocks_from_daily_data(prev_trading_date)
        
        # 获取前前一个交易日（用于判断是否为首板）
        prev_2_trading_date = self.get_last_trading_date(prev_trading_date)
        print(f"前前一个交易日: {prev_2_trading_date}")
        
        limit_up_2_days_ago = self.get_limit_up_stocks_from_daily_data(prev_2_trading_date)
        
        # 计算首板股票（昨日涨停但前日未涨停）
        first_board_stocks = [stock for stock in limit_up_stocks if stock not in limit_up_2_days_ago]
        
        # 保存股票池数据
        pool_data = {
            'target_date': target_date,
            'prev_trading_date': prev_trading_date,
            'prev_2_trading_date': prev_2_trading_date,
            'limit_up_stocks': limit_up_stocks,
            'limit_up_2_days_ago': limit_up_2_days_ago,
            'first_board_stocks': first_board_stocks,
            'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # 保存到JSON文件
        pool_file = os.path.join(self.pool_data_dir, f"pool_{target_date}.json")
        import json
        with open(pool_file, 'w', encoding='utf-8') as f:
            json.dump(pool_data, f, ensure_ascii=False, indent=2)
        
        print(f"股票池生成完成！")
        print(f"- 前一日涨停股票数量: {len(limit_up_stocks)}")
        print(f"- 前前日涨停股票数量: {len(limit_up_2_days_ago)}")
        print(f"- 首板股票数量: {len(first_board_stocks)}")
        print(f"保存路径: {pool_file}")
        
        return pool_data
    
    def load_stock_pool(self, date_str: str) -> Dict:
        """加载指定日期的股票池"""
        pool_file = os.path.join(self.pool_data_dir, f"pool_{date_str}.json")
        if os.path.exists(pool_file):
            import json
            with open(pool_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    
    def batch_generate_stock_pool(self, start_date: str, end_date: str):
        """批量生成指定时间段的股票池数据"""
        from datetime import datetime, timedelta
        
        start_dt = datetime.strptime(start_date, '%Y-%m-%d')
        end_dt = datetime.strptime(end_date, '%Y-%m-%d')
        
        current_date = start_dt
        processed_dates = []
        
        print(f"开始批量生成 {start_date} 到 {end_date} 的股票池数据...")
        
        while current_date <= end_dt:
            date_str = current_date.strftime('%Y-%m-%d')
            
            # 检查该日期是否有对应的日线数据
            has_data_for_date = False
            for file in os.listdir(self.daily_data_dir)[:100]:  # 只检查前100个文件
                if file.endswith('.csv'):
                    csv_path = os.path.join(self.daily_data_dir, file)
                    try:
                        df = pd.read_csv(csv_path)
                        if 'date' in df.columns:
                            df['date'] = pd.to_datetime(df['date'])
                            if pd.to_datetime(date_str) in df['date'].values:
                                has_data_for_date = True
                                break
                    except:
                        continue
            
            if has_data_for_date:
                print(f"正在生成 {date_str} 的股票池...")
                try:
                    # 生成股票池（这会自动覆盖已存在的文件）
                    pool_data = self.generate_stock_pool(date_str)
                    processed_dates.append(date_str)
                    print(f"  - 已生成 {date_str}")
                except Exception as e:
                    print(f"  - 生成 {date_str} 时出错: {e}")
            else:
                print(f"  - 跳过 {date_str} (无对应日线数据)")
            
            current_date += timedelta(days=1)
        
        print(f"批量生成完成！共处理了 {len(processed_dates)} 个交易日")
        print(f"处理的日期: {processed_dates}")
        return processed_dates

    def get_latest_data_date(self) -> str:
        """获取本地数据的最新日期"""
        latest_date = None
        for file in os.listdir(self.daily_data_dir):
            if file.endswith('.csv'):
                csv_path = os.path.join(self.daily_data_dir, file)
                try:
                    df = pd.read_csv(csv_path)
                    if 'date' in df.columns:
                        df['date'] = pd.to_datetime(df['date'])
                        file_latest = df['date'].max()
                        if latest_date is None or file_latest > latest_date:
                            latest_date = file_latest
                except:
                    continue
        
        if latest_date:
            return latest_date.strftime('%Y-%m-%d')
        return "无数据"

def main():
    """主函数 - 演示股票池生成"""
    print("股票池生成器")
    print("="*50)
    
    generator = StockPoolGenerator()
    
    # 获取当前日期作为目标日期
    target_date = datetime.now().strftime('%Y-%m-%d')
    
    print(f"当前日期: {target_date}")
    
    # 获取本地数据最新日期
    latest_data_date = generator.get_latest_data_date()
    print(f"本地数据最新日期: {latest_data_date}")
    
    if latest_data_date == "无数据":
        print("没有找到本地数据，请先下载数据")
        return
    
    # 询问用户操作类型
    print(f"\n请选择操作类型:")
    print("1. 单日生成股票池")
    print("2. 批量生成股票池（指定时间段）")
    
    choice = input("请输入选项 (1 或 2): ")
    
    if choice == "1":
        target_date = input(f"请输入目标日期 (格式 YYYY-MM-DD，默认 {target_date}): ") or target_date
        
        print(f"\n是否要生成 {target_date} 的股票池？")
        print("这将使用前一个交易日的数据来生成涨停股票池")
        
        response = input("输入 'y' 确认生成，其他键退出: ")
        if response.lower() != 'y':
            print("取消生成")
            return
        
        # 生成股票池
        pool_data = generator.generate_stock_pool(target_date)
        
        print(f"\n股票池生成完成！")
        print(f"前一日涨停股票 (共{len(pool_data['limit_up_stocks'])}只): {pool_data['limit_up_stocks'][:10]}...")  # 显示前10只
        print(f"首板股票 (共{len(pool_data['first_board_stocks'])}只): {pool_data['first_board_stocks'][:10]}...")  # 显示前10只
    
    elif choice == "2":
        print("批量生成股票池（会覆盖已有数据）")
        start_date = input("请输入开始日期 (格式 YYYY-MM-DD): ")
        end_date = input("请输入结束日期 (格式 YYYY-MM-DD): ")
        
        if start_date and end_date:
            print(f"\n是否要生成 {start_date} 到 {end_date} 的股票池？")
            print("(这将覆盖已存在的数据)")
            
            response = input("输入 'y' 确认生成，其他键退出: ")
            if response.lower() != 'y':
                print("取消生成")
                return
            
            # 批量生成股票池
            processed_dates = generator.batch_generate_stock_pool(start_date, end_date)
            
            print(f"\n批量生成完成！")
        else:
            print("日期输入不完整")
    
    else:
        print("无效选项")


if __name__ == "__main__":
    main()